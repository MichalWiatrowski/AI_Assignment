#include "Game.h"
//Constructor
Game::Game(sf::RenderWindow* hwnd)
{
	window = hwnd;

	// Load from a font file on disk
	if (!font.loadFromFile("resources/arial.ttf"))
	{
		std::cout << "Could not load font" << std::endl;
	}

	//Init SFML and any variables
	backgroundTexture.loadFromFile("resources/background.png");
	backgroundObject.setSize(sf::Vector2f(800, 600));
	backgroundObject.setPosition(sf::Vector2f((window->getSize().x / 2), (window->getSize().y / 2)));
	backgroundObject.setTexture(&backgroundTexture);
	backgroundObject.setOrigin(400, 300);

	raceLineTexture.loadFromFile("resources/raceline.png");
	raceLineObject.setSize(sf::Vector2f(60, 400));
	raceLineObject.setPosition(sf::Vector2f((window->getSize().x /2) - 30, (window->getSize().y / 2) - 200));
	raceLineObject.setTexture(&raceLineTexture);

	carCubeTexture.loadFromFile("resources/car.png");
	carCubeObject.setSize(sf::Vector2f(60, 120));
	carCubeObject.setPosition(sf::Vector2f((window->getSize().x / 2) - 30, (window->getSize().y / 2) + 60));
	carCubeObject.setTexture(&carCubeTexture);
	
	///////////////////////////////////////////////////////////////

	distanceText.setFont(font);
	distanceText.setFillColor(sf::Color::Black);
	distanceText.setPosition(10, 0);

	velocityText.setFont(font);
	velocityText.setFillColor(sf::Color::Black);
	velocityText.setPosition(285, 0);

	outputText.setFont(font);
	outputText.setFillColor(sf::Color::Black);
	outputText.setPosition(560, 0);

	goingLeftText.setFont(font);
	goingLeftText.setFillColor(sf::Color::Red);
	goingLeftText.setPosition(10, 550);
	goingLeftText.setString("Driving Left");

	goingStraightText.setFont(font);
	goingStraightText.setFillColor(sf::Color::Red);
	goingStraightText.setPosition(300, 550);
	goingStraightText.setString("Driving Straight");

	goingRightText.setFont(font);
	goingRightText.setFillColor(sf::Color::Red);
	goingRightText.setPosition(610, 550);
	goingRightText.setString("Driving Right");

	modeText.setFont(font);
	modeText.setFillColor(sf::Color::Blue);
	modeText.setPosition(320, 50);

	///////////////////////////////////////////////////////////////

	velocity = 0.0f;
	raceLineVelocity = 900.0f;
	carControlState = new StateMachine(&goingLeftText, &goingStraightText, &goingRightText);
}
Game::~Game()
{
}
//Run in test mode: Allow the user to input velocity and distance and display the output generated by fuzzylite (version 6.0)
void Game::testing(fl::Engine* engine, float deltaTime)
{
	std::cout << "////////// Running in test mode! //////////" << std::endl;

	std::cout << "Would you like to test FUZZY or FSM (Please enter 1 or 2 respectively)" << std::endl;
	std::cin >> ifTesting;

	if (ifTesting == "1")
	{
		appState = TestingFuzzy;
	}
	else if (ifTesting == "2")
	{
		appState = TestingFSM;
	}

	system("CLS"); //clears the console

	//reset the values for new input
	ifTesting = "";

	if (appState == TestingFSM)
	{
		//Open the file in append mode
		std::fstream log;
		log.open("log.csv", std::fstream::app);

		std::cout << "Writing values to file!" << std::endl;
	
		//Start simulating the vehicle coming from the right
		log << "Distance" << "," << "Velocity" << "\n";
		for (int j = -60; j <= 600; j += 60)
		{
			testDistance = j - 600;
			testVelocity = carControlState->update(600, j, deltaTime);
			log << testDistance << "," << testVelocity << "\n";
		}

		//Add a "divider" to the file to easily find the middle of the simulation
		log << " --------------- \n";

		//Start simulating the vehicle coming from the left
		for (int j = 660; j >= 0; j -= 60)
		{
			testDistance = j - 0;
			testVelocity = carControlState->update(0, j, deltaTime);
			log << testDistance << "," << testVelocity << "\n";
		}
		//close the file
		log.close();
	}
	else if (appState == TestingFuzzy)
	{
		//Allow the user to enter values
		std::cout << "Please enter test data (negative values represent the left side of the line" << std::endl; std::cout << "and positive values represent the right side of the line)" << std::endl;

		std::cout << "Please enter the velocity (between -1 and 1)" << std::endl;
		std::cin >> testVelocity;

		std::cout << "Please enter the distance (between -1 and 1)" << std::endl;
		std::cin >> testDistance;

		//Calculate and display the output
		std::cout << "The output is " << update(engine, -1, testVelocity, (testDistance)) << std::endl;
	}
	

	std::cout << "Would you like to keep testing? (y/n)" << std::endl;
	std::cin >> ifTesting;

	if (ifTesting == "N" || ifTesting == "n")
	{
		appState = ApplicationFuzzyLogic;

		std::cout << "////////// Running in application mode! //////////" << std::endl;
		std::cout << "Please switch over to the other window (do not close this one!)" << std::endl;
		std::cout << "To return to testing, press T/t while having the sfml window selected" << std::endl;
	}
	system("CLS"); //clears the console

	//reset the values for new input
	testVelocity = testDistance = 0;
	ifTesting = "";
}

//Run in application mode: Allow the user to move the race line to show the fuzzy logic AI in action
void Game::application(fl::Engine* engine, float deltaTime)
{
	updateUI(deltaTime);
	//calculate the distance
	distance = ((raceLineObject.getPosition().x - carCubeObject.getPosition().x) / 800);
	//get velocity before new calculation for UI
	

	if (appState == ApplicationFuzzyLogic)
	{
		//Calculate and get the new velocity with fuzzy logic
		velocity = update(engine, deltaTime, velocity, distance);
		//Update the position of the car
		carCubeObject.move(velocity * 1600, 0);
	}
	else if (ApplicationFSM)
	{
		//Calculate and get the new velocity with FSM
		velocity = carControlState->update(carCubeObject.getPosition().x, raceLineObject.getPosition().x, deltaTime);
		//Store for UI
		output = velocity;
		//Update the position of the car
		carCubeObject.move(velocity * 5, 0);
	}
	else
	{
		std::cout << "An error has occured, please press any button to shut down the application" << std::endl;
		system("PAUSE");
		exit(0);
	}
}

float Game::update(fl::Engine* engine, float deltaTime, float vel, float dis)
{
	//Set the inputs
	engine->getInputVariable(0)->setValue(dis);
	engine->getInputVariable(1)->setValue(vel);

	//Process the data
	engine->process();

	//Retrieve the output
	outputVariable = engine->getOutputVariable(0);

	//Store for UI
	output = -outputVariable->getValue();

	if (appState == TestingFuzzy)
	{
		//When testing, return the original output
		return (outputVariable->getValue());
	}
	else
	{ 
		//WHen running the application, minus the new distance from the old distance to get the velocity and then return it
		return (dis - outputVariable->getValue()) * deltaTime;
	}
}

//Handel input
void Game::handleInput(Input* input, float deltaTime)
{
	if (input->isKeyDown(sf::Keyboard::Num1))
	{
		raceLineVelocity = 100;
	}
	else if (input->isKeyDown(sf::Keyboard::Num2))
	{
		raceLineVelocity = 300;
	}
	else if (input->isKeyDown(sf::Keyboard::Num3))
	{
		raceLineVelocity = 900;
	}
	else if (input->isKeyDown(sf::Keyboard::Num4))
	{
		raceLineVelocity = 3000;
	}

	if (input->isKeyDown(sf::Keyboard::A))
	{
		//if the user clicks A, move the line left
		if (raceLineObject.getPosition().x > 0)
			raceLineObject.setPosition(raceLineObject.getPosition().x - (raceLineVelocity * deltaTime), raceLineObject.getPosition().y);
	}
	if (input->isKeyDown(sf::Keyboard::D))
	{
		//if the user clicks D, move the line right
		if (raceLineObject.getPosition().x < 740)
			raceLineObject.setPosition(raceLineObject.getPosition().x + (raceLineVelocity * deltaTime), raceLineObject.getPosition().y);
	}

	if (input->isKeyDown(sf::Keyboard::F))
	{
		//if the player clicks F, teleport the race line to far right
		raceLineObject.setPosition(740, raceLineObject.getPosition().y);
	}
	if (input->isKeyDown(sf::Keyboard::T))
	{
		//if the player clicks T, switch to test mode

		appState = TestingFuzzy;
		system("CLS"); //clears the console for testing
	}
	if (input->isKeyDown(sf::Keyboard::R))
	{
		//if the player clicks T, switch between the two AI types
		input->setKeyUp(sf::Keyboard::R);
		if (appState == ApplicationFuzzyLogic)
			appState = ApplicationFSM;
		else if (appState == ApplicationFSM)
			appState = ApplicationFuzzyLogic;
	}
}

//Render the SFML window
void Game::render()
{
	beginDraw();
	//Render the sprites
	window->draw(backgroundObject);
	window->draw(raceLineObject);
	window->draw(carCubeObject);

	//Render the calculations text
	window->draw(distanceText);
	window->draw(velocityText);
	window->draw(outputText);

	//Render the indicator texts
	window->draw(goingLeftText);
	window->draw(goingStraightText);
	window->draw(goingRightText);

	window->draw(modeText);
	endDraw();
}
void Game::beginDraw()
{
	window->clear(sf::Color::Black);
}
void Game::endDraw()
{
	window->display();
}

//Function for updating the UI
void Game::updateUI(float deltaTime)
{
	//if the app is running in FSM mode
	if (appState == ApplicationFSM)
	{
		modeText.setString("Mode: FSM");
		velocityText.setString("Velocity: " + std::to_string(velocity));
	}
	//if it is running in fuzzy logic mode
	else if (appState == ApplicationFuzzyLogic)
	{
		modeText.setString("Mode: Fuzzy");
		//If the car is going left
		if (velocity < 0 && distance <= -marginalDistance)
		{
			goingLeftText.setFillColor(sf::Color::Green);
			goingStraightText.setFillColor(sf::Color::Red);
			goingRightText.setFillColor(sf::Color::Red);
		}
		//If the car is going right
		else if (velocity > 0 && distance >= marginalDistance)
		{
			goingLeftText.setFillColor(sf::Color::Red);
			goingStraightText.setFillColor(sf::Color::Red);
			goingRightText.setFillColor(sf::Color::Green);
		}
		//Otherwise it is going straight
		else
		{
			goingLeftText.setFillColor(sf::Color::Red);
			goingStraightText.setFillColor(sf::Color::Green);
			goingRightText.setFillColor(sf::Color::Red);
		}
		velocityText.setString("Velocity: " + std::to_string(velocity / deltaTime));	
	}
	//Set new values for the texts
	outputText.setString("Output: " + std::to_string(output));
	distanceText.setString("Distance: " + std::to_string(distance));
}
